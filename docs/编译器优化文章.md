# 编译器优化文章

> 姓名：严皓钧
>
> 学号：21371372



## 一、 死代码删除

​	在死代码删除部分中,主要分为**删除无用代码**和**删除不可达代码**两部分.其中对于不可达代码的删除,其实是不会减少最终final cycle的,但是由于可以减少较多的无用代码, 让debug变得更加直接,因此还是十分有用的.

- 对于无用代码,我主要处理了以下两种情况
	- 无用的指令 : 构建一个有用指令的闭包
	- 无用的函数 : 根据有无其他函数使用该函数进行判断
- 对于不可达代码, 我主要处理了以下两种情况
	- 不可达的指令: 将基本块第一条分支跳转指令后面的所有指令全部删除
	- 不可达的基本块:采用DFS遍历基本块.

​	这里仅展开分析**无用指令的删除**,因为这个对性能有明显的提升.并且实现的逻辑相对来说较复杂.总体来说,我采用的也是教程中提供的构建有用指令的闭包,具体步骤如下:

- 首先遍历基本块中的指令,如果指令是Call , Br , Ret 和 Store , 则标记为有用指令. 
- 再次遍历函数中的指令,如果当前指令被标记为有用指令,则从当前指令出发标记其所使用到的Value, 构建处一个有用指令的闭包
- 最后再次遍历指令,删除没有被标记的指令.



## 二、 Mem2Reg

​	由于在我们生成的代码中，只是保证了虚拟寄存器是SSA的，但是其实从内存的角度看来并非如此。比如说在一个简单的if - else分支语句之中，可能就存在多条对同一内存进行赋值的store语句，因此也就是还没实现内存上的SSA。

​	在Mem2Reg中，主要经过了三个阶段：构建CFG 、 插入phi指令和变量重命名。接下来将详细介绍这三个步骤的具体实现和难点。

### 2.1 构建CFG

​	CFG(Control Flow Diagram)主要描述的是以基本块为单位，程序中基本块之间的相互关系。由于在插入Phi指令的时候，需要利用的基本块之间的相互支配关系，因此在进行Mem2Reg之前我们必须先对CFG进行构建。这里需要注意的是，在构建CFG的时候需要先对基本块中的不可达代码进行消除，**否则当选择基本块的最后一条指令作为分析的依据时将会出现问题**。

​	CFG的构建可以分为以下步骤：

- 构建每一个基本块的前驱prev和后继next

​	遍历每个基本块的最后一条指令，如果是分支跳转（Br）语句，则从指令中获取要跳转到达的基本块，则维护nextsMap和prevsMap这两个数据结构，从而构建出完整的前驱和后继关系。

```java
if (instruction instanceof Br) {
	BasicBlock trueBlock = ((Br) instruction).getTrueBlock();
	BasicBlock falseBlock = ((Br) instruction).getFalseBlock();

	nextsMap.get(function).get(basicBlock).add(trueBlock);
	prevsMap.get(function).get(trueBlock).add(basicBlock);

	if (falseBlock != null) {
		nextsMap.get(function).get(basicBlock).add(falseBlock);
		prevsMap.get(function).get(falseBlock).add(basicBlock);
	}
}
```

- 根据CFG图计算支配关系

​	在构建出前驱和后继关系之后，就可以计算基本块之间的支配关系，这里我采用的是迭代计算的方式：(dom指的是支配该基本块的基本块)

>  某个基本块的dom <- 某基本块所有前驱的dom的交集加上自己本身

​	在代码实现上，只需不断迭代不断判断是否有dom集合更新即可，如果仍有更新则意味着迭代仍未结束。

- 构建直接支配关系

​	严格支配其实就是 {支配} - {自己}，判断的时候逻辑较为简单。这里的主要难点在于如何构建直接支配关系。直接支配关系是严格支配n，且不严格支配任何严格支配n的节点的节点，根据这个判断设计的逻辑如下：

```java
            for (BasicBlock dominator : dominators) {
                if (dominator.equals(basicBlock)) {
                    /*strict dominate*/
                    continue;
                }
                //严格支配n，且不严格支配任何严格支配n的节点的节点
                boolean isImmediate = true;
                for (BasicBlock other : dominators) {
                    if(!other.equals(basicBlock) && !other.equals(dominator) && 																																domMap.get(function).get(other).contains(dominator)) {
                        isImmediate = false;
                        break;
                    }
                }
            }
```

​	这里首先遍历支配该基本块n的基本块dominator，第一个if条件保证dominator是严格支配的。在此基础上，再遍历一次直接支配的基本块，判断该基本块dominator是否严格支配 严格支配n的其他基本块other。如果不存在这样的情况，那么就代表即为基本块的直接支配。

- 构建DF支配边界

​	构建DF的算法虽然原理比较复杂，但是构造出来直接支配的数据结构之后，只需要根据伪代码进行翻译即可。

<img src="编译器优化文章/Screenshot 2023-11-29 at 10.39.12-1322439.png" alt="Screenshot 2023-11-29 at 10.39.12" style="zoom: 50%;" />

```java
private void buildDF(Function function) {
        HashMap<BasicBlock,ArrayList<BasicBlock>> curNextsMap = nextsMap.get(function);
        for (HashMap.Entry<BasicBlock, ArrayList<BasicBlock>> entry : curNextsMap.entrySet()) {
            for (BasicBlock b : entry.getValue()) {                //for all edges
                BasicBlock x = entry.getKey();   //x <- a
                while (!domMap.get(function).get(b).contains(x) || x.equals(b)) {
                    //while x doesn't strictly dominate b <-> x doest not domiate b or x equals b
                    dfMap.get(function).get(x).add(b);
                    x = iDomMap.get(function).get(x);
                }
            }
        }
}
```



### 2.2 插入Phi指令

​	在构造出来基本块的支配边界之后，就可以对生成的LLVM代码中插入Phi指令。插入Phi指令的目的是转换为

​	插入Phi的基本原理如下图所示：

<img src="编译器优化文章/Screenshot 2023-11-29 at 12.45.15-1322439.png" alt="Screenshot 2023-11-29 at 12.45.15" style="zoom:50%;" />

​	这里的难点在于理解这段伪代码的含义，并将其与LLVM的架构结合在在一起

- 该伪代码首先构造了集合$W$，集合$W$包含了所有对变量$v$的定义点。在我们的LLVM中，变量$v$其实就是$alloca$指令得到的虚拟寄存器，然后对变量$v$的重新定义其实是对该虚拟寄存器的$store$指令。因此，构建集合$W$其实就是构建一个从$alloca$到$List<BasicBlock>$的映射。
- 对于集合$W$中的每个基本块$X$，遍历基本块$X$的支配边界$Y$，并且在支配边界$Y$的入口处插入一条空的$\phi$指令，相当于标识此处需要有一条 $\phi$ 。这里的意思是，$Y$中变量$v$的值可能来自与$X$。

- 最后需要判断是否有$Y \in Defs(v)$，相当于值$v$在$Y$被汇总后，可能会在后面被再汇总，因此需要加入到集合$W$之中。有点类似河流的两个支流先汇聚，然后再汇入支流....，直到汇入到干流中。



### 2.3 变量重命名

​	在插入$phi$指令的时候，我们相当于切割了变量的存活区间，因此需要为每段区间中的phi指令进行重新命名，从而保证和进行Mem2Reg之前的代码保持一致。

​	变量重命名的基本原理如下：

<img src="编译器优化文章/Screenshot 2023-11-29 at 13.11.36-1322439.png" alt="Screenshot 2023-11-29 at 13.11.36" style="zoom:50%;" />

​	这部分主要可以分为以下两个阶段：

- 遍历指令并更新到达定义数据流

​	在第一部分中，我们需要DFS遍历每个基本块（DFS可以采用直接支配）中的指令：

> 如果非$phi$指令$i$使用了变量$v$，那么更新到达定义，并且将使用到变量$v$的都替换为到达定义中的新变量
>
> 如果指令$i$对变量$v$进行了定义，那么就先更新到达定义，然后将该指令作为新的到达定义进行更新。

​	对这段伪代码进行进一步的解释，即如下图所示：（引用自https://roife.github.io/posts/mem2reg-pass/）

<img src="编译器优化文章/image-20231129142600408-1322439.png" alt="image-20231129142600408" style="zoom:33%;" />

​	$load$对应的是上述规则的第一条，$phi$和$store$指令对应的是上述规则中的第二条，在理清了这个事情之后实现也就较为简单了。

```java
            if (instr instanceof Alloca && allocas.contains(instr)) {   // remove instr from basic block
                iterator.remove();
            } else if (instr instanceof Load) {
                if (instr.getOperand(0) instanceof Alloca && allocas.contains((Alloca) 																																														instr.getOperand(0))) {
                    Value newValue = newIncomingValues.get((Alloca) instr.getOperand(0)).peek();
                    instr.replaceAllUseWithValue(newValue);
                    iterator.remove();
                }
            } else if (instr instanceof Store) {
                if (instr.getOperand(1) instanceof Alloca &&  allocas.contains((Alloca) 																																													instr.getOperand(1))) {
                    Value value = instr.getOperand(0);
                    newIncomingValues.get((Alloca) instr.getOperand(1)).push(value);
                    iterator.remove();        
                }
            } else if (instr instanceof Phi) {
                if (newPhis.containsKey(instr)) {
                    newIncomingValues.get(newPhis.get(instr)).push(instr);
                }
            }
```



- 更新$Phi$指令

​	最后，我们需要不断更新$Phi$指令的值，将后继的基本块中所有的$Phi$更新为新的到达定义。这里需要注意的是，要把操作数operand和对应的基本块的位置信息保持一致。

```Java
        for (BasicBlock successor : nextsMap.get(basicBlock)) {
            for (IRInstruction instr1 : successor.getInstructions()) {
                if (instr1 instanceof Phi phi) {
                    Alloca alloca = newPhis.get(phi);
                    Value value = newIncomingValues.get(alloca).peek();
                    phi.addPhiOperand(value, basicBlock);
                }
            }
        }
```



## 三、 Phi消除

​	在进行了Mem2Reg之后，LLVM中间代码中包含了大量的$Phi$指令，但是其实$Phi$指令实际上是无法被常规的汇编指令表示的，所以我们需要对$Phi$进行消除，最终用$Move$这样的赋值语句代替。

​	在进行$Phi$消除的时候，我们需要分为两个步骤来进行：

-  关键边切割

​	该步骤的伪代码如下图所示：

<img src="编译器优化文章/Screenshot 2023-11-29 at 14.53.23-1322439.png" alt="Screenshot 2023-11-29 at 14.53.23" style="zoom:55%;" />

​	这段伪代码的过程是：首先对于CFG中的每个基本块$B$，遍历这个基本块对应的所有前驱$B_i$，如果前驱$B_i$有多个后继，那么就创建一个新的基本块$B_i^{'}$，并且在新的基本块中加入$PC_i$ 。这里需要特别注意维护基本块之间的数据结构；反之，就直接在$B_i$的结尾添加上$PC_i$。

​	最后遍历基本块中的$Phi$，更新$PC_i$中的值并且删除$Phi$指令，这样便实现了去除$Phi$指令。



- $PC$转换为$Move$

​	将$PC$转换为$Move$的算法的伪代码如下：

<img src="编译器优化文章/Screenshot 2023-11-29 at 15.10.13-1322439.png" alt="Screenshot 2023-11-29 at 15.10.13" style="zoom: 50%;" />

​	我们需要利用算法将$PC$翻译为$move$而不能直接将$PC$拆成$move$的原因在于：$PC$代表的是一种**并行赋值**，如果直接翻译为move的顺序序列，那么会导致程序的语义与之前出现不同，最终导致翻译出错。

​	其实这段代码的核心内容就是在不断解决**循环赋值**的问题，如果不存在循环赋值，即对于$b \leftarrow a$，如果不存在$c \leftarrow b$，代表着对$b$的值修改了之后不会影响其他赋值，那么就可以直接进行转换；如果存在循环赋值，那么就要先创建一个新的值$a^{'}$，往最终的move序列先增加一句$a^{'} \leftarrow a$，然后替换$pc$中的值再继续迭代。



## 四、 公共子表达式删除

​	LVN(Local Variable Numbering) 即局部值编号，效果基本等同于公共子表达式消除，可以大量减少冗余的求值。我采取的LVN的方式为：

- 为每个基本块初始化一个哈希表
- 对每条指令根据操作数和操作符计算哈希值
- 如果哈希表中已经存在哈希值，那么将基本块使用到这个value的值全部进行替换 ； 否则将哈希值存入哈希表。

​	上述步骤的逻辑转换为代码实现如下：

```Java
constantFolding(basicBlock); 	//常量折叠
IRInstruction instr = iterator.next();
if (!canEliminate(instr)) {
		continue;
}
String hashValue = getHashValue(instr); 
if (hashMap.get(basicBlock).containsKey(hashValue)) {
		instr.replaceAllUseWithValue(hashMap.get(basicBlock).get(hashValue));
		iterator.remove();
} else {
		hashMap.get(basicBlock).put(hashValue,instr);
}
```

上述代码中涉及到三个方法，一个是constantFolding常量折叠，一个是canEliminate,一个是getHashValue获取哈希值，下面将详细展开这三个方法的设计：

- constantFolding

​	在constantFolding中，首先需要判断二元计算表达式中常量的个数。

​	如果常量的个数为2，则可以直接根据表达式的类型计算得到结果。相当于在编译的过程中就把已经确定的数先计算了，这样就避免了在后端代码生成中进行大量的常量之间的计算。

​	如果常量的个数为1或者0，虽然无法直接计算得到确切的结果，但是可以根据四则运算中的特性对其进行优化，以下是我实现的优化：

```
a + 0 = a	  //可以左右替换
a - 0 = a
a * 0 = 0
a * 1 = a
a / 1 = a
a % 1 = 0
a % a = 0
a / a = 1
```



- canEliminate

​	这个方法主要判断的是这条指令可不可以被消除掉，其实也就是判断合并之后会不会对程序的运行结果产生副作用。这里可以进行一点讨论：

​	首先对于计算类的指令，比如add,sub等等，都是可以合并掉的。其次对于Call指令，并不是所有的函数调用都可以合并，一个很简单的例子是：

```C
int func1(){
		printf("123");
  	return 0;
}
int func2(){
    return 0;
}
int main() {
  int x,y;
  x = func1();
  y = func1();
  
  x = func2();
  y = func2();
  return 0;
}
```

​	这其中两次调用func1，显然是不能合并的，不然就会导致结果只输出一次“123”，与正确的结果不同；但是对于func2，我们其实可以只调用一次，实现公共子表达式删除的。因此，在对Call进行合并的时候需要进行一定的条件判断，我最终进行的判断条件如下：

```Java
//这里需要对call指令进行以下条件的判断，都满足的时候才可以进行
//1. 不存在对函数的调用
//2. 形参没有数组->只有int
//3. 有返回值
//4. 纯函数判断:不对全局变量进行修改 && 没有I/O
```



- getHashValue

​	这个方法的作用就是“对每条指令根据操作数和操作符计算哈希值”。值得一提的是，由于加法、乘法的左右操作数替换并不会影响结果，因此可以映射到相同的哈希值中。



## 五、 寄存器分配

​	寄存器分配是整个编译器优化过程中十分重要的一环，要合理地利用有限的寄存器资源分配给LLVM中的“虚拟寄存器”。在没进行寄存器分配之前，正如前文所述，后端翻译的过程中要经过大量的从栈中读取数据，然后再将计算结果存入栈中。而在进行了寄存器分配之后，我们可以大幅度减少对内存的操作，从而提升后端代码的运行性能。

​	我实现的寄存器分配主要基于图着色算法，通过活跃变量分析和基本块内的使用与定义关系，来确定变量的生命周期，并据此决定寄存器的分配。虽然我并没有将冲突图构建出来，按照理论课程中的启发式算法进行寄存器分配，但是基本思路都是基于图着色算法。

​	在本部分中，首先需要先对活跃变量进行分析，然后基于活跃变量分析结果进行寄存器分配。

- 活跃变量分析

​	在活跃变量计算部分中，首先要先计算出每个基本块的$def$和$use$，这里按照理论课程中的定义进行计算即可。这里需要特别注意的是，使用到的value只可能是：指令、参数以及全局变量。在计算得到$def$和$use$之后，便对基本块的数据流进行遍历，按照活跃变量分析的公式不断更新$in$和$out$，直到不再有更新为止。



- 寄存器分配策略

​	这部分是寄存器分配的核心部分，主要使用到的寄存器分配规则有以下两条：

> 如果某个变量在本基本块中最后一次被使用，并且基本块的$out$集合不包含该变量，则将该变量对应的寄存器释放。

​	如果某个变量在本基本块中最后一次被使用，那么意味着当前基本块中后续的指令都不会使用这个变量了；同时，$out$集合也不包含该变量，那么意味着这个基本块后续的基本块也用不到该变量，变量的“生命周期”到此为止，可以把为其分配的寄存器进行回收。

> 在分配完本基本块后，准备分配直接支配的基本块$idom$之前，先释放$idom$的$in$集合中不包含的值对应的寄存器。

​	在分配完一个基本块之后，由于是递归分配，如果现在寄存器中某个值在$idom$中暂时用不到，可以先将其暂时释放，等分配完了$idom$之后再进行恢复。

​	基于这两条规则，我们的寄存器分配流程如下：

对于一个基本块，遍历每一条指令：

1. 对于这个指令所使用到的$value$，如果符合规则1并且为这个$value$分配了寄存器，那么将其对应的寄存器进行释放。

2. 如果这个指令有产生新的$def$，那么尝试为这个新的变量分配一个寄存器，如果分配了就保存分配结果。

分配完这个基本块后，遍历其每一个直接支配的基本块：

1. 如果存在符合规则2的变量，那么将其变量-寄存器映射关系暂时解除并记录，等分配完该基本块（递归返回）之后再重新恢复映射关系。



## 六、 分支优化

​	由于在删除Phi的时候，产生了大量用于维护“中间代码正确性”的基本块，因此可以对基本块中的分支跳转进行优化，合并不必要的跳转，从而降低final cycle。在分支优化部分，我主要做的有以下两种优化：

- 优化仅有一句直接跳转的基本块

```
bb1:      
	br bb2
```

​	这样的基本块中仅有一句直接跳转语句，因此可以把所有基本块中跳转到bb1的语句全部替换为跳转到bb2，这样就可以省去无意义的分支跳转

- 优化只有一个前驱的基本块

```
bb1:
	...
	br bb2
	
bb2:
	...
```

​	如果一个基本块block只有一个前驱prev，那么意味着基本块block只可能从prev跳转到达，并且prev仅有一个后继，因此可以将prev与block进行合并，具体操作为：将prev的跳转语句删除，然后将block中的所有指令加入到prev的末尾之中。

​	在进行上述两个优化的时候，要特别注意维护基本块的前驱、后继结构。



## 七、运算强度削弱

​	在本部分中，主要是在LLVM代码生成MIPS代码时，将可以进行优化的乘法、除法以及模运算进行运算强度削弱。

- 乘法优化

​	乘法部分的运算强度优化较为简单，主要涉及到的两个函数是：

```Java
    public static Boolean is2Power(int n) {
        return (n & (n - 1)) == 0;
    }

    public static int getCLZ(int number) {
        int power = 0;
        while (number > 1) {
            number >>= 1;
            power++;
        }
        return power;
    }
```

​	第一个函数`is2Power`判断整数n是否为2的幂次，第二个函数`getCLZ`负责计算整数number对应的幂次（向下）。优化的策略是检测操作数是否为2的幂（或2的幂附近的数），并使用位移操作替换乘法。对于接近2的幂的数，在使用了位移操作替换后还需要对结果进行修正，保证优化的正确性。

​	这里值得一提的是，为了保证能够正确实现计算，需要在优化开始前先判断是否为负数，如果是负数在替换结束之后需要使用subu来对计算结果取反。

- 除法与模优化

​	除法与模的优化大致思路类似，当除数是2的幂时，除法可以通过位移操作来实现。在其他情况下，需要首先计算出multiplier和shift，然后通过计算出来的乘数，然后使用乘法和位移操作来模拟除法或者取模。计算multiplier和shift的定理如下：

<img src="编译器设计文档/Screenshot 2023-12-10 at 16.02.16.png" alt="Screenshot 2023-12-10 at 16.02.16" style="zoom:50%;" />

